package;

import flixel.FlxG;
import flixel.FlxSprite;
import flixel.graphics.frames.FlxAtlasFrames;
lastSegment = new BossSegment(lastSprite, 60, backSegment);
import flixel.math.FlxMath;
import flixel.math.FlxPoint;
import flixel.util.FlxColor;

squishFactor = 0;
headSegment.setCenter(headX, headY);
foreSegment.setCenter(headX, headY + 25);
backSegment.setCenter(headX, headY + 45);
lastSegment.setCenter(headX, headY + 60);
updateMouthAndPincers();
flixel.group.FlxGroup.FlxTypedGroup;
class BossPhase01Larva extends FlxTypedGroup<FlxSprite> implements IBoss
{
	public var maxHealth:Float = 1000;
	public var currentHealth:Float = 1000;
	public var contactDamage:Float = 1.0;
	public var width:Float = 40;
	public var height:Float = 40;

	var headSegment:BossSegment;
	var foreSegment:BossSegment;
	var backSegment:BossSegment;
	var lastSegment:BossSegment;
	var squishFactor:Float = 0;

	var mouth:FlxSprite;
	var pincers:FlxSprite;

	var mode:BossMode = IDLE;
	var modeTimer:Float = 0;
	var isReady:Bool = false;

	public var x(get, never):Float;
	public var y(get, never):Float;

	var headX:Float;
	var headY:Float;
	var baseX:Float;
	var baseY:Float;
	var targetX:Float;
	var targetY:Float;
	var moveSpeed:Float = 20;
	var wiggleTime:Float = 0;
	var wiggleAmplitude:Float = 0.3;
	var wiggleFrequency:Float = 5;

	var attackCallback:Void->Void;
	var spitProjectiles:FlxTypedGroup<Projectile>;

	var mouthOpen:Bool = false;
	var pincersOpen:Bool = false;
	var pincerWiggleTimer:Float = 0;

	public function new(X:Float, Y:Float, ?AttackCallback:Void->Void, ?SpitProjectiles:FlxTypedGroup<Projectile>)
	{
		super();

		headX = X;
		headY = Y;
		baseX = X;
		baseY = Y;
		targetX = X;
		targetY = Y;
		attackCallback = AttackCallback;
		spitProjectiles = SpitProjectiles;

		var lastSprite = new FlxSprite();
		lastSprite.loadGraphic(AssetPaths.boss_phase_01_larva_last_segment__png);
		lastSprite.alpha = 0;
		add(lastSprite);

		var backSprite = new FlxSprite();
		backSprite.loadGraphic(AssetPaths.boss_phase_01_larva_back_segment__png);
		backSprite.alpha = 0;
		add(backSprite);

		var foreSprite = new FlxSprite();
		foreSprite.loadGraphic(AssetPaths.boss_phase_01_larva_fore_segment__png);
		foreSprite.alpha = 0;
		add(foreSprite);

		var headSprite = new FlxSprite();
		headSprite.loadGraphic(AssetPaths.boss_phase_01_larva_head__png);
		headSprite.alpha = 0;
		add(headSprite);

		mouth = new FlxSprite();
		mouth.loadGraphic(AssetPaths.boss_phase_01_larva_mouth__png, true, 6, 9);
		mouth.animation.add("closed", [0]);
		mouth.animation.add("open", [1]);
		mouth.animation.play("closed");
		mouth.alpha = 0;
		add(mouth);

		pincers = new FlxSprite();
		pincers.loadGraphic(AssetPaths.boss_phase_01_larva_pincers__png, true, 22, 13);
		pincers.animation.add("closed", [0]);
		pincers.animation.add("open", [1]);
		pincers.animation.play("closed");
		pincers.alpha = 0;
		add(pincers);

		headSegment = new BossSegment(headSprite, 0, null);
		foreSegment = new BossSegment(foreSprite, 25, headSegment);
		backSegment = new BossSegment(backSprite, 45, foreSegment);
		lastSegment = new BossSegment(lastSprite, 60, backSegment);

		squishFactor = 0;
		lastSegment.setCenter(headX, headY - 60);
		backSegment.setCenter(headX, headY - 45);
		foreSegment.setCenter(headX, headY - 25);
		headSegment.setCenter(headX, headY);

		updateMouthAndPincers();
		currentHealth = maxHealth;
	}

	function updateSegments():Void
	{
		headSegment.setCenter(headX, headY);
		foreSegment.setCenter(headX, headY - 25);
		backSegment.setCenter(headX, headY - 45);
		lastSegment.setCenter(headX, headY - 60);

		applyWiggle();
	}

	function applyWiggle():Void
	{
		var wiggle1 = Math.sin(wiggleTime + 0) * wiggleAmplitude;
		var wiggle2 = Math.sin(wiggleTime + 0.8) * wiggleAmplitude;
		var wiggle3 = Math.sin(wiggleTime + 1.6) * wiggleAmplitude;

		foreSegment.sprite.offset.y += wiggle1;
		backSegment.sprite.offset.y += wiggle2;
		lastSegment.sprite.offset.y += wiggle3;
	}

	function updateMouthAndPincers():Void
	{
		var headCenter = headSegment.getCenter();
		mouth.x = headCenter.x - mouth.width / 2;
		mouth.y = headCenter.y - mouth.height / 2;
		pincers.x = headCenter.x - pincers.width / 2;
		pincers.y = headCenter.y - pincers.height / 2;
		headCenter.put();
	}

	function setMouthOpen(open:Bool):Void
	{
		if (mouthOpen == open)
			return;
		mouthOpen = open;
		mouth.animation.play(open ? "open" : "closed");
	}

	function setPincersOpen(open:Bool):Void
	{
		if (pincersOpen == open)
			return;
		pincersOpen = open;
		pincers.animation.play(open ? "open" : "closed");
	}

	public function fadeIn(progress:Float):Void
	{
		forEach(function(spr:FlxSprite)
		{
			spr.alpha = progress;
		});
	}

	public function unfurl(progress:Float):Void
	{
		squishFactor = progress;
		headY = baseY + (progress * 30);
		if (progress >= 1.0)
		{
			baseY = headY;
		}

		foreSegment.sprite.offset.y = -foreSegment.baseOffsetY * progress;
		backSegment.sprite.offset.y = -backSegment.baseOffsetY * progress;
		lastSegment.sprite.offset.y = -lastSegment.baseOffsetY * progress;

		updateSegments();
		updateMouthAndPincers();
	}

	public function getHeadPosition():FlxPoint
	{
		return headSegment.getCenter();
	}

	public function moveTo(x:Float, y:Float, speed:Float, elapsed:Float):Void
	{
		wiggleTime += elapsed * wiggleFrequency;

		var dx = x - headX;
		var dy = y - headY;
		var dist = Math.sqrt(dx * dx + dy * dy);

		if (dist > 1)
		{
			var angle = Math.atan2(dy, dx);
			headX += Math.cos(angle) * speed * elapsed;
			headY += Math.sin(angle) * speed * elapsed;
		}

		updateSegments();
		updateMouthAndPincers();
	}

	public function isAtPosition(x:Float, y:Float):Bool
	{
		var dx = x - headX;
		var dy = y - headY;
		return (dx * dx + dy * dy) < 100;
	}

	public function setReady():Void
	{
		isReady = true;
		targetX = headX;
		targetY = headY;
		modeTimer = 0;
	}

	public function roar():Void
	{
		setMouthOpen(true);
		setPincersOpen(true);
	}

	public function closeRoar():Void
	{
		setMouthOpen(false);
		setPincersOpen(false);
	}

	override function update(elapsed:Float):Void
	{
		super.update(elapsed);

		if (!isReady)
		{
			return;
		}

		modeTimer += elapsed;

		switch (mode)
		{
			case IDLE:
				updateIdle(elapsed);
			case SLAM_ATTACK:
				updateSlamAttack(elapsed);
			case SPIT_ATTACK:
				updateSpitAttack(elapsed);
		}

		updateSegments();
		updateMouthAndPincers();
	}

	function updateIdle(elapsed:Float):Void
	{
		wiggleTime += elapsed * 3;
		pincerWiggleTimer += elapsed;

		if (pincerWiggleTimer > FlxG.random.float(0.5, 2.0))
		{
			setPincersOpen(!pincersOpen);
			pincerWiggleTimer = 0;
		}

		setMouthOpen(false);

		var dx = targetX - headX;
		var dy = targetY - headY;
		var distSq = dx * dx + dy * dy;

		if (distSq < 25)
		{
			pickNewWanderTarget();
		}
		else
		{
			var angle = Math.atan2(dy, dx);
			headX += Math.cos(angle) * moveSpeed * elapsed;
			headY += Math.sin(angle) * moveSpeed * elapsed;
		}

		if (modeTimer > 5.0)
		{
			modeTimer = 0;
			if (FlxG.random.bool(50))
			{
				startSlamAttack();
			}
			else
			{
				startSpitAttack();
			}
		}
	}

	function updateSlamAttack(elapsed:Float):Void
	{
		if (modeTimer < 1.2)
		{
			setMouthOpen(true);
			setPincersOpen(true);

			var raiseProgress = modeTimer / 1.2;
			var raise = 80 * raiseProgress;

			headSegment.sprite.offset.y = -raise;
			foreSegment.sprite.offset.y = -(foreSegment.baseOffsetY + raise * 0.75);
			backSegment.sprite.offset.y = -(backSegment.baseOffsetY + raise * 0.5);
			lastSegment.sprite.offset.y = -(lastSegment.baseOffsetY + raise * 0.25);
		}
		else if (modeTimer < 1.3)
		{
			setMouthOpen(true);
			setPincersOpen(true);

			var slamProgress = (modeTimer - 1.2) / 0.1;
			var targetOffset = 80 * (1 - slamProgress);

			headSegment.sprite.offset.y = -targetOffset;
			foreSegment.sprite.offset.y = -(foreSegment.baseOffsetY + targetOffset * 0.75);
			backSegment.sprite.offset.y = -(backSegment.baseOffsetY + targetOffset * 0.5);
			lastSegment.sprite.offset.y = -(lastSegment.baseOffsetY + targetOffset * 0.25);
		}
		else if (modeTimer < 1.35)
		{
			setMouthOpen(true);
			setPincersOpen(true);

			headSegment.sprite.offset.y = 0;
			foreSegment.sprite.offset.y = -foreSegment.baseOffsetY;
			backSegment.sprite.offset.y = -backSegment.baseOffsetY;
			lastSegment.sprite.offset.y = -lastSegment.baseOffsetY;

			if (attackCallback != null)
			{
				attackCallback();
				attackCallback = null;
			}
		}
		else if (modeTimer > 1.9)
		{
			setMouthOpen(false);
			setPincersOpen(false);
			mode = IDLE;
			modeTimer = 0;
			pickNewWanderTarget();
		}
		else
		{
			setMouthOpen(false);
			setPincersOpen(false);

			headSegment.sprite.offset.y = 0;
			foreSegment.sprite.offset.y = -foreSegment.baseOffsetY;
			backSegment.sprite.offset.y = -backSegment.baseOffsetY;
			lastSegment.sprite.offset.y = -lastSegment.baseOffsetY;
			updateSegments();
		}
	}

	function updateSpitAttack(elapsed:Float):Void
	{
		if (modeTimer < 0.3)
		{
			setMouthOpen(true);
			setPincersOpen(true);
		}
		else if (modeTimer < 0.8)
		{
			setMouthOpen(true);
			setPincersOpen(true);
			if (Std.int(modeTimer * 10) % 2 == 0 && spitProjectiles != null)
			{
				spitProjectile();
			}
		}
		else if (modeTimer < 1.1)
		{
			setMouthOpen(false);
			setPincersOpen(false);
		}
		else
		{
			setMouthOpen(false);
			setPincersOpen(false);
			mode = IDLE;
			modeTimer = 0;
		}
	}

	function spitProjectile():Void
	{
		var proj:Projectile = spitProjectiles.getFirstAvailable(Projectile);
		if (proj == null)
		{
			proj = new Projectile();
			spitProjectiles.add(proj);
		}

		var spawnX = mouth.x + mouth.origin.x;
		var spawnY = mouth.y + mouth.origin.y + mouth.height / 2;
		proj.reset(spawnX, spawnY);
		proj.damage = contactDamage;
		proj.makeGraphic(4, 4, FlxColor.GREEN);

		var targetX:Float = spawnX + 1;
		var targetY:Float = spawnY;
		if (Std.isOfType(FlxG.state, PlayState))
		{
			var ps:PlayState = cast FlxG.state;
			if (ps.player != null)
			{
				targetX = ps.player.x + ps.player.width / 2;
				targetY = ps.player.y + ps.player.height / 2;
			}
		}

		var angle = Math.atan2(targetY - spawnY, targetX - spawnX);
		var speed = 160;
		proj.velocity.x = Math.cos(angle) * speed;
		proj.velocity.y = Math.sin(angle) * speed;
		proj.acceleration.set(0, 0);
	}

	function startSlamAttack():Void
	{
		mode = SLAM_ATTACK;
		modeTimer = 0;
		attackCallback = function()
		{
			FlxG.camera.shake(0.015, 0.3);
			createShockwave();
		};
	}

	function createShockwave():Void
	{
		if (spitProjectiles == null)
			return;

		var numProjectiles = 80;
		var shockwaveSpeed = 120;
		var center = headSegment.getCenter();

		for (i in 0...numProjectiles)
		{
			var angle = (i / numProjectiles) * Math.PI * 2;
			var proj:Projectile = spitProjectiles.getFirstAvailable(Projectile);
			if (proj == null)
			{
				proj = new Projectile();
				spitProjectiles.add(proj);
			}
			proj.reset(center.x, center.y);
			proj.damage = contactDamage * 0.5;
			proj.makeGraphic(4, 4, FlxColor.ORANGE);
			proj.velocity.x = Math.cos(angle) * shockwaveSpeed;
			proj.velocity.y = Math.sin(angle) * shockwaveSpeed;
			proj.acceleration.set(0, 0);
		}
		center.put();
	}

	function startSpitAttack():Void
	{
		mode = SPIT_ATTACK;
		modeTimer = 0;
	}

	function pickNewWanderTarget():Void
	{
		var arenaCenterX = FlxG.worldBounds.width / 2;
		var arenaCenterY = FlxG.worldBounds.height / 2;
		targetX = arenaCenterX + FlxG.random.float(-40, 40);
		targetY = arenaCenterY + FlxG.random.float(-30, 30);
	}

	public function takeDamage(damage:Float):Void
	{
		currentHealth -= damage;
		if (currentHealth < 0)
			currentHealth = 0;
		if (currentHealth <= 0)
			die();
	}

	public function die():Void
	{
		alive = false;
		exists = false;
		forEach(function(spr:FlxSprite)
		{
			spr.kill();
		});
	}

	function get_x():Float
	{
		return headX;
	}

	function get_y():Float
	{
		return headY;
	}

	override function destroy():Void
	{
		headSegment.destroy();
		foreSegment.destroy();
		backSegment.destroy();
		lastSegment.destroy();
		super.destroy();
	}
}

enum BossMode
{
	IDLE;
	SLAM_ATTACK;
	SPIT_ATTACK;
}
